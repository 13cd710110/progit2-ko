//////////////////////////
==== Git and Perforce
//////////////////////////
==== Git과 Perforce

(((Interoperation with other VCSs, Perforce)))
(((Perforce)))
//////////////////////////
Perforce is a very popular version-control system in corporate environments.
It's been around since 1995, which makes it the oldest system covered in this chapter.
As such, it's designed with the constraints of its day; it assumes you're always connected to a single central server, and only one version is kept on the local disk.
To be sure, its features and constraints are well-suited to several specific problems, but there are lots of projects using Perforce where Git would actually work better.
//////////////////////////
Perforce는 기업용 환경에서 유명한 버전 관리 시스템이다.
1995년 무렵부터 사용되었으며 이 장에서 다루는 다른 시스템에 비해 가장 오래된 버전 관리 시스템이다.
처음 Perforce를 사용할 당시 환경을 고려하여 설계되었기에 가정하는 환경 특성이 몇 가지 다르다. 우선 항상 네트워크를 통해 중앙 서버에 연결되어있고 하나의 버전만 로컬 환경에서 유지할 수 있다.
몇 가지 특정한 프로젝트의 Workflow에서는 Perforce가 잘 맞을 수 있지만 Git을 도입해서 훨씬 나은 Workflow를 적용할 수 있는 프로젝트도 많을 것이라 생각된다.

//////////////////////////
There are two options if you'd like to mix your use of Perforce and Git.
The first one we'll cover is the ``Git Fusion'' bridge from the makers of Perforce, which lets you expose subtrees of your Perforce depot as read-write Git repositories.
The second is git-p4, a client-side bridge that lets you use Git as a Perforce client, without requiring any reconfiguration of the Perforce server.
//////////////////////////
Perforce와 Git을 조합해서 사용하는 방법으로 2가지 중 하나를 고를 수 있다.
첫 번째는 ``Git Fusion'' 으로 Perforce가 제공하는 Bridge를 사용하는 것이며 ??? TODO
두 번째 방법은 git-p4라는 클라이언트 Bridge를 사용하여 Perforce의 클라이언트로 Git을 사용하는 것이다. 이 방법을 사용하면 따로 Perforce 서버를 재구축할 필요가 없다.

[[_p4_git_fusion]]
===== Git Fusion

(((Perforce, Git Fusion)))
//////////////////////////
Perforce provides a product called Git Fusion (available at http://www.perforce.com/git-fusion[]), which synchronizes a Perforce server with Git repositories on the server side.
//////////////////////////
Perforce는 Git Fusion(http://www.perforce.com/git-fusion[] 에서 다운로드 받을 수 있음)이라는 제픔을 제공하는데 이 제품은 Perforce 서버와 서버에 저장해서 사용하는 Git 저장소의 내용을 동기화 한다.

//////////////////////////
====== Setting Up
//////////////////////////
====== Git Fusion 설치

//////////////////////////
For our examples, we'll be using the easiest installation method for Git Fusion, which is downloading a virtual machine that runs the Perforce daemon and Git Fusion.
You can get the virtual machine image from http://www.perforce.com/downloads/Perforce/20-User[], and once it's finished downloading, import it into your favorite virtualization software (we'll use VirtualBox).
//////////////////////////
예제로 알아볼 사용법은 Git Fusion을 사용하는 방법 중 가장 쉬운 방법으로 Git Fusion이 포함된 가상머신 이미지를 다운로드 받아서 Perforce 데몬과 Git Fusion을 동작시키는 것이다.
가상머신 이미지는 http://www.perforce.com/downloads/Perforce/20-User[] 의 `Git Fusion` 탭에서 받을 수 있으며 받고 나서 가상머신 이미지를 동작시킬 수 있는 프로그램으로 가져오기 해서 사용할 수 있다. 책의 예제에서는 VirtualBox를 사용한다.

//////////////////////////
Upon first starting the machine, it asks you to customize the password for three Linux users (`root`, `perforce`, and `git`), and provide an instance name, which can be used to distinguish this installation from others on the same network. When that has all completed, you'll see this:
//////////////////////////
가상머신을 처음 부팅시키면 `root`, `perforce`, `git` 세 리눅스 계정의 비밀번호를 입력하라는 화면과 가상머신 인스턴스 이름을 입력하라는 화면이 나타난다. 인스턴스 이름은 같은 네트워크 안에서 인스턴스를 구분하고 접근하기 위해 사용하는 이름이다. 이러한 과정을 마치고 나면 다음과 같은 화면을 볼 수 있다.

//////////////////////////
.The Git Fusion virtual machine boot screen.
image::images/git-fusion-boot.png[The Git Fusion virtual machine boot screen.]
//////////////////////////
.Git Fusion 가상머신 부팅 화면.
image::images/git-fusion-boot.png[Git Fusion 가상머신 부팅 화면.]

//////////////////////////
You should take note of the IP address that's shown here, we'll be using it later on.
Next, we'll create a Perforce user.
Select the ``Login'' option at the bottom and press enter (or SSH to the machine), and log in as `root`.
Then use these commands to create a user:
//////////////////////////
우선 이어지는 예제에서 계속 사용하기 때문에 화면에서 나타나는 IP주소를 기억해두어야 한다.
다음 과정으로 Perforce 사용자를 생성한다.
``Login'' 항목으로 이동해서 엔터키를 누르면(또는 가상머신으로 SSH 접속을 하면) `root`로 쉘이 뜬다.
아래 명령으로 Perforce 사용자를 생성할 수 있다.

[source,console]
----
$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit
----

//////////////////////////
The first one will open a VI editor to customize the user, but you can accept the defaults by typing `:wq` and hitting enter.
The second one will prompt you to enter a password twice.
That's all we need to do with a shell prompt, so exit out of the session.
//////////////////////////
첫 번째 명령을 실행하면 VI 편집기가 뜨고 생성한 사용자의 정보를 수정할 수 있다. 기본으로 입력되어있는 정보를 그대로 사용하려면 간단히 `:wq` 를 키보드로 입력하고 엔터키를 누른다.
두 번째 명령을 실행하면 생성한 Perforce 사용자의 비밀번호를 입력하게 되는데 확인까지 해서 두 번 입력한다.
쉘 상에서 할 작업은 여기까지므로 exit를 입력하여 쉘 사용을 마친다.

//////////////////////////
The next thing you'll need to do to follow along is to tell Git not to verify SSL certificates.
The Git Fusion image comes with a certificate, but it's for a domain that won't match your virtual machine's IP address, so Git will reject the HTTPS connection.
If this is going to be a permanent installation, consult the Perforce Git Fusion manual to install a different certificate; for our example purposes, this will suffice:
//////////////////////////
다음으로 해야 할 작업은 클라이언트 환경에서 Git이 SSL 인증서를 검증하지 않도록 설정하는 것이다.
Git Fusion 이미지에 포함된 SSL 인증서는 도메인 이름을 기준으로 접속을 검증하게 되는데 예제에서는 IP 주소로 접근을 하기 때문에 Git이 HTTPS 인증서를 검증하는 과정에서 실패하여 접속할 수 없다.
예제로 구축하는 Git Fusion 가상머신 이미지를 실제로 사용하고자 한다면 Perforce Git Fusion 메뉴얼을 참고하여 새로 SSL 인증서를 설치해서 사용하는 것을 권한다. 예제로만 사용하려면 인증서 검증하지 않기 옵션만 설정하면 된다.

[source,console]
----
$ export GIT_SSL_NO_VERIFY=true
----

//////////////////////////
Now we can test that everything is working.
//////////////////////////
제대로 작동하는지 아래 명령으로 확인해보자.

[source,console]
----
$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.
----

//////////////////////////
The virtual-machine image comes equipped with a sample project that you can clone.
Here we're cloning over HTTPS, with the `john` user that we created above; Git asks for credentials for this connection, but the credential cache will allow us to skip this step for any subsequent requests.
//////////////////////////
Perforce가 제공한 가상머신 이미지는 안에 샘플 프로젝트를 하나 포함한다.
위의 예제 명령에서는 앞서 만든 `john`이라는 사용자 이름과 암호를 가지고 HTTPS 프로토콜을 통해 프로젝트를 Clone 한다. Credential 캐시를 통해 다음 명령부터는 사용자 이름과 암호 입력을 건너뛸 수 있다.

//////////////////////////
====== Fusion Configuration
//////////////////////////
====== Git Fusion 설정

//////////////////////////
Once you've got Git Fusion installed, you'll want to tweak the configuration.
This is actually fairly easy to do using your favorite Perforce client; just map the `//.git-fusion` directory on the Perforce server into your workspace.
The file structure looks like this:
//////////////////////////
Git Fusion 설치를 완료한 후에도 설정을 변경하여 사용할 수도 있다.
이미 잘 쓰고 있는 Perforce 클라이언트가 있다면 어렵지 않게 설정을 변경할 수 있다. Perforce 서버의 `//.git-fusion` 디렉토리를 Workspace 안에 추가해서 사용하면 된다.

[source,console]
----
$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files
----

//////////////////////////
The `objects` directory is used internally by Git Fusion to map Perforce objects to Git and vice versa, you won't have to mess with anything in there.
There's a global `p4gf_config` file in this directory, as well as one for each repository – these are the configuration files that determine how Git Fusion behaves.
Let's take a look at the file in the root:
//////////////////////////
`objects` 디렉토리는 Git Fusion이 Perforce 객체와 Git을 양방향으로 대응시키는 내용을 담고 있으므로 이 디렉토리 안의 내용을 임의로 수정하지 말아야 한다.
`p4gf_config` 파일은 루트 디렉토리에, 그리고 각 저장소마다 하나씩 있으며 Git Fusion이 어떻게 동작하는지를 설정하는 파일이다.
루트 디렉토리의 이 파일 내용을 보면 아래와 같다.

[source,ini]
----
[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no
----

//////////////////////////
We won't go into the meanings of these flags here, but note that this is just an INI-formatted text file, much like Git uses for configuration.
This file specifies the global options, which can then be overridden by repository-specific configuration files, like `repos/Talkhouse/p4gf_config`.
If you open this file, you'll see a `[@repo]` section with some settings that are different from the global defaults.
You'll also see sections that look like this:
//////////////////////////
이 책에서는 이 파일 내용 한 줄 한 줄 그 의미를 설명하지는 않는다. Git에서 사용하는 환경설정 파일과 마찬가지로 INI 형식으로 관리된다는 점을 알아두면 된다.
루트 디렉토리에 위차한 환경설정 파일의 내용은 `repos/Talkhouse/p4gf_config` 처럼 각 저장소의 환경설정 파일이 덮어쓰여 적용하게 된다.
각 저장소별 환경설정 파일의 내용을 보면 아래와 같을 Section이 있을 수 있다.

[source,ini]
----
[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...
----

//////////////////////////
This is a mapping between a Perforce branch and a Git branch.
The section can be named whatever you like, so long as the name is unique.
`git-branch-name` lets you convert a depot path that would be cumbersome under Git to a more friendly name.
The `view` setting controls how Perforce files are mapped into the Git repository, using the standard view mapping syntax.
More than one mapping can be specified, like in this example:
//////////////////////////
파일 내용을 보면 Perforce와 Git의 브랜치간 매핑 정보를 볼 수 있다.
Section 이름은 겹치지만 않게 아무런 이름이나 사용할 수 있다.
`git-branch-name` 항목은 길고 입력하기 어려운 Depot 경로를 Git에서 사용하기에 편한 이름으로 연결해준다.
`view` 항목은 Perforce 파일이 Git 저장소에 어떻게 대응되는지를 View 매핑 문법을 사용하여 설정한다.
여러 항목을 설정할 수 있으며 예제는 아래와 같다.

[source,ini]
----
[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...
----

//////////////////////////
This way, if your normal workspace mapping includes changes in the structure of the directories, you can replicate that with a Git repository.
//////////////////////////
이와 같은 식으로 구성하면 특정 디렉토리 안의 변경사항이 Git 저장소로 반영되게 된다.

//////////////////////////
The last file we'll discuss is `users/p4gf_usermap`, which maps Perforce users to Git users, and which you may not even need.
When converting from a Perforce changeset to a Git commit, Git Fusion's default behavior is to look up the Perforce user, and use the email address and full name stored there for the author/committer field in Git.
When converting the other way, the default is to look up the Perforce user with the email address stored in the Git commit's author field, and submit the changeset as that user (with permissions applying).
In most cases, this behavior will do just fine, but consider the following mapping file:
//////////////////////////
마지막으로 살펴볼 설정파일은 `users/p4gf_usermap` 파일로 Perforce 사용자를 Git 사용자로 매핑하는 역할을 하는데 때에 따라서는 필요하지 않을 수도 있다.
Perforce Chagneset을 Git의 커밋으로 변환할 때 Git Fusion은 Perforce 사용자의 이름과 이메일 주소를 가지고 Git 커밋의 저자와 커미터 정모를 입력한다.
반대로 Git 커밋을 Perforce Chagneset으로 변환할 때는 Git 커밋에 저장된 이름과 이메일 정보를 가져와 Changeset에 기록하고 이 정보로 권한을 확안하게 된다.
대부분의 경우 리모트 저장소에 동일한 정보로 등록이 되어있다면 문제없겠지만 다른 정보로 등록이 되어있다면 아래와 같이 매핑 정보를 설정할 수 있다.

[source]
----
john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"
----

//////////////////////////
Each line is of the format `<user> <email> "<full name>"`, and creates a single user mapping.
The first two lines map two distinct email addresses to the same Perforce user account.
This is useful if you've created Git commits under several different email addresses (or change email addresses), but want them to be mapped to the same Perforce user.
When creating a Git commit from a Perforce changeset, the first line matching the Perforce user is used for Git authorship information.
//////////////////////////
각 줄은 `ID 이메일 "<긴 이름>"`으로 구성하여 한 유저에 대한 매핑 설정을 한다.
첫 번째 줄과 두 번째 줄은 두 이메일 주소를 한 Perforce 유저로 매핑한다.
이렇게 설정하면 Git 커밋을 만들 때 여러 이름이나 이메일 주소를 사용한 경우 유용하게 한 Perforce 유저의 Changeset으로 변환할 수 있다.
Perforce Chageset을 Git 커밋으로 변경할 때는 첫 번째 매치가 되는 매핑 정보를 이용하여 커밋의 저자 정보를 기록한다.

//////////////////////////
The last two lines mask Bob and Joe's actual names and email addresses from the Git commits that are created.
This is nice if you want to open-source an internal project, but don't want to publish your employee directory to the entire world.
Note that the email addresses and full names should be unique, unless you want all the Git commits to be attributed to a single fictional author.
//////////////////////////
마지막 두 줄은 Perforce 사용자 bob도 joe도 Git 커밋으로 변환할 때는 다른 이름을 쓰도록 설정한 것이다.
내부 프로젝트를 오픈소스로 공개할 때 이름을 드러내지 않고 외부로 오픈할 경우 유용하게 쓸 수 있다.
물론 여러 사람의 Changeset을 마치 한 사람이 작성한 Git 커밋처럼 변환시키지 않으려면 매핑 정보에서는 긴 이름과 이메일 주소가 다른 항목과 겹치지 않아야 한다.

====== Workflow

//////////////////////////
Perforce Git Fusion is a two-way bridge between Perforce and Git version control.
Let's have a look at how it feels to work from the Git side.
We'll assume we've mapped in the ``Jam'' project using a configuration file as shown above, which we can clone like this:
//////////////////////////
Perforce의 Git Fusion은 Git과 Perforce사이에서 양방향의 데이터 변환을 지원하는 Bridge이다.
Git을 Perforce의 클라이언트로 사용할 때 어떤식으로 사용하면 되는지 예제를 통해 살펴보기로 한다.
위에서 살펴본 설정파일로 ``Jam'' 이라는 Perforce 프로젝트를 아래와 같이 Clone 할 수 있다.

[source,console]
----
$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://ben@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]
----

//////////////////////////
The first time you do this, it may take some time.
What's happening is that Git Fusion is converting all the applicable changesets in the Perforce history into Git commits.
This happens locally on the server, so it's relatively fast, but if you have a lot of history, it can still take some time.
Subsequent fetches do incremental conversion, so it'll feel more like Git's native speed.
//////////////////////////
먼저 처음 저장소를 Clone 할 때는 시간이 무지 많이 걸릴 수 있다.
Git Fusion이 Perforce 저장소에서 가져온 모든 Changeset을 Git 커밋으로 변환하기 때문이다.
변환하는 과정이야 빠르더라도 히스토리 자체 크기가 크다면 전체 Clone하는 시간은 오래 걸리기 마련이다.
이렇게 한 번 전체를 Clone 한 이후에 추가된 내용만을 받아오는 시간은 Git과 마찬가지로 오래걸리지 않는다.

//////////////////////////
As you can see, our repository looks exactly like any other Git repository you might work with.
There are three branches, and Git has helpfully created a local `master` branch that tracks `origin/master`.
Let's do a bit of work, and create a couple of new commits:
//////////////////////////
Clone 받아온 저장소는 지금까지 살펴본 일반적인 Git 저장소와 거의 비슷하고 보기에 익숙한 느낌이 든다.
브랜치를 확인해보면 3개가 있다. 먼저 Git은 로컬 `master` 브랜치가 서버의 `origin/master` 브랜치를 추적하도록 미리 만들어둔 것을 볼 수 있다.
내키는대로 파일을 좀 수정하고 커밋을 두어번 하면 다음과 같이 히스토리가 쌓인 모습을 볼 수 있게 될 것이다.

[source,console]
----
# ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

//////////////////////////
We have two new commits.
Now let's check if anyone else has been working:
//////////////////////////
새 커밋 두 개가 로컬 히스토리에 쌓였다.
다른 사람이 Push한 일이 있는지 확인해보자.

[source,console]
----
$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -> origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

//////////////////////////
It looks like someone was!
You wouldn't know it from this view, but the `6afeb15` commit was actually created using a Perforce client.
It just looks like another commit from Git's point of view, which is exactly the point.
Let's see how the Perforce server deals with a merge commit:
//////////////////////////
그새 누군가 부지런히 일을 했나보다(역주: 물론 저자가 했겠지).
정확히 누가 어떤 일을 했는지는 커밋을 까봐야 알겠지만 어쨋든 Git Fusion은 서버로부터 새로 가져온 Changeset을 변환해서 `6afeb15` 커밋을 만들어놨다.
계속 Git에서 본 여타 커밋이랑 다르지 않다.
이제 Perforce 서버가 Merge 커밋을 어떻게 다룰지 살펴보기로 한다.

[source,console]
----
$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -> master
----

//////////////////////////
Git thinks it worked.
Let's take a look at the history of the `README` file from Perforce's point of view, using the revision graph feature of `p4v`:
//////////////////////////
Git은 이렇게 Merge하고 Push하면 잘 되었겠거니 한다.
Perforce의 관점에서 `README` 파일의 히스토리를 생각해보자. Perforce 히스토리는 `p4v` 그래프 기능으로 볼 수 있다.

//////////////////////////
.Perforce revision graph resulting from Git push.
image::images/git-fusion-perforce-graph.png[Perforce revision graph resulting from Git push.]
//////////////////////////
.Git이 Push한 Perforce 리비전 결과 그래프.
image::images/git-fusion-perforce-graph.png[Git이 Push한 Perforce 리비전 결과 그래프.]

//////////////////////////
If you've never seen this view before, it may seem confusing, but it shows the same concepts as a graphical viewer for Git history.
We're looking at the history of the `README` file, so the directory tree at top left only shows that file as it surfaces in various branches.
At top right, we have a visual graph of how different revisions of the file are related, and the big-picture view of this graph is at bottom right.
The rest of the view is given to the details view for the selected revision (`2` in this case).
//////////////////////////
Perforce의 이런 히스토리 뷰어를 본 적이 없다면 다소 혼란스러울 수 있지만 Git 히스토리를 보는 것과 크게 다르지 않다.
그림은 `README` 파일의 히스토리를 보고 있는 상황이다. 왼쪽 위 창에서 `README` 파일과 관련된 브랜치와 디렉토리가 나타난다.
오른쪽 위 창에서는 파일의 리비전 히스토리 그래프를 볼 수 있다. 오른쪽 아래 창에서는 이 그래프의 큰 그림을 확인할 수 있다.

//////////////////////////
One thing to notice is that the graph looks exactly like the one in Git's history.
Perforce didn't have a named branch to store the `1` and `2` commits, so it made an ``anonymous'' branch in the `.git-fusion` directory to hold it.
This will also happen for named Git branches that don't correspond to a named Perforce branch (and you can later map them to a Perforce branch using the configuration file).
//////////////////////////
Perforce의 히스토리 그래프는 Git의 히스토리 그래프와 많이 닮은 모양이다.
Perforce는 커밋 `1`과 `2`에 브랜치 이름을 기록하지 않았다. `.git-fusion` 디렉토리의 ``anonymous'' 브랜치로 이 두 커밋을 관리하여 Merge를 했다.
Git 브랜치가 Perforce의 브랜치와 매치되지 않은 경우에도 이와 같은 모양이 된다(나중에 설정파일에 브랜치간 매핑을 설정할 수도 있다).

//////////////////////////
Most of this happens behind the scenes, but the end result is that one person on a team can be using Git, another can be using Perforce, and neither of them will know about the other's choice.
//////////////////////////
이런 작업들은 Git Fusion 내부에서 보이지 않게 처리된다. 물론 이 결과로 인해 최소한 같이 작업하는 한 사람은 Perforce 저장소를 Git 클라이언트로 접근해서 일한다는 것을 누군가는 알게된다.

//////////////////////////
====== Git-Fusion Summary
//////////////////////////
====== Git-Fusion 요약

//////////////////////////
If you have (or can get) access to your Perforce server, Git Fusion is a great way to make Git and Perforce talk to each other.
There's a bit of configuration involved, but the learning curve isn't very steep.
This is one of the few sections in this chapter where cautions about using Git's full power will not appear.
That's not to say that Perforce will be happy with everything you throw at it – if you try to rewrite history that's already been pushed, Git Fusion will reject it – but Git Fusion tries very hard to feel native.
You can even use Git submodules (though they'll look strange to Perforce users), and merge branches (this will be recorded as an integration on the Perforce side).
//////////////////////////
사용하는 Perforce 서버 저장소가 있다면 Git Fusion을 Git으로 Perforce 서버와 데이터를 주고받는 아주 유용한 도구로 쓸 수 있다.
물론 좀 설정해야 하는 부분도 있지만 익히는게 그리 어렵지는 않다.
이 장에서는 대부분 Git의 강력한 기능을 제한적으로 사용하라고 주의시키지만 이 절은 그렇지 않고 Git의 다양한 기능 사용을 권한다.
그렇다고 Perforce 서버로 아무렇게나 커밋을 Push 할 수는 없다. Git에서도 이미 Push한 커밋을 재작성하고 Push하면 커밋을 거절한다. 이런 경우에도 Git Fusion은 열심히 노력해서 Perforce를 마치 Git 처럼 다룰 수 있게 도와준다.s
(Perforce 사용자에게는 생소하겠지만) Git 서브모듈도 사용할 수 있고 브랜치(Perforce 쪽에서 기록)를 Merge 할 수도 있다.

//////////////////////////
If you can't convince the administrator of your server to set up Git Fusion, there is still a way to use these tools together.
//////////////////////////
서버에 Git Fusion 설치하고 관리할 권한이 없지만 그래도 Git을 Perforce 클라이언트로 사용하겠다면 다른 대안이 없지는 않다.

===== Git-p4

(((git commands, p4)))
//////////////////////////
Git-p4 is a two-way bridge between Git and Perforce.
It runs entirely inside your Git repository, so you won't need any kind of access to the Perforce server (other than user credentials, of course).
Git-p4 isn't as flexible or complete a solution as Git Fusion, but it does allow you to do most of what you'd want to do without being invasive to the server environment.
//////////////////////////
Git-p4도 마찬가지로 Git과 Perforce간의 양방향 Bridge이다.
Git-p4는 모든 작업이 Git 저장소의 데이터만을 사용하기 때문에 Perforce 서버 없이도 사용할 수 있다. 물론 인증정보는 Perforce 서버가 필요하다.
Git-p4는 Git Fusion 만큼 완성도 높고 쉽게 Git과 연동해서 사용할 수는 없지만 Perforce 서버를 방해하지 않고 Git의 대부분의 기능을 이용할 수 있게 해준다.

[NOTE]
======
//////////////////////////
You'll need the `p4` tool somewhere in your `PATH` to work with git-p4.
As of this writing, it is freely available at http://www.perforce.com/downloads/Perforce/20-User[].
//////////////////////////
git-p4가 잘 동작하려면 `p4` 명령을 어디에서나 사용할 수 있게 `PATH`에 등록해두어야 한다.
`p4`는 무료로 http://www.perforce.com/downloads/Perforce/20-User[] 에서 다운로드 받을 수 있다.
======

//////////////////////////
====== Setting Up
//////////////////////////
====== 설정

//////////////////////////
For example purposes, we'll be running the Perforce server from the Git Fusion OVA as shown above, but we'll bypass the Git Fusion server and go directly to the Perforce version control.
//////////////////////////
예제로 사용할 Perforce 프로젝트를 가져오기 위해 앞에서 살펴본 Git Fusion OVA 이미지의 Perforce 서버를 사용한다. Git Fusion 서버 설정은 건너뛰고 Perforce 서버와 저장소 설정 부분만 설정하면 된다.

//////////////////////////
In order to use the `p4` command-line client (which git-p4 depends on), you'll need to set a couple of environment variables:
//////////////////////////
git-p4이 의존하는 `p4` 클라이언트를 커맨드라인에서 사용하기 위해 몇 가지 환경변수를 먼저 설정해야 한다.

[source,console]
----
$ export P4PORT=10.0.1.254:1666
$ export P4USER=john
----

//////////////////////////
====== Getting Started
//////////////////////////
====== 시작하기

//////////////////////////
As with anything in Git, the first command is to clone:
//////////////////////////
Git에서 모든 시작은 Clone부터 하듯 마찬가지로 Clone을 먼저 한다.

[source,console]
----
$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master
----

//////////////////////////
This creates what in Git terms is a ``shallow'' clone; only the very latest Perforce revision is imported into Git; remember, Perforce isn't designed to give every revision to every user.
This is enough to use Git as a Perforce client, but for other purposes it's not enough.
//////////////////////////
Git의 언어로 표현하자면 위의 명령은 ``shallow'' Clone을 한다. 모든 저장소의 히스토리를 가져오지 않고 마지막 리비전의 히스토리만 가져온다. 이 점을 기억해두어야 한다. Perforce는 저장소의 모든 히스토리를 모든 사용자에게 허용하지 않게 설계되었다. 따라서 이렇게 마지막 리비전만을 가져와도 Git을 Perforce 클라이언트로 충분히 사용할 수 있다. 물론 전체 히스토리를 봐야하는 의도라면 충분하지 않다.

//////////////////////////
Once it's finished, we have a fully-functional Git repository:
//////////////////////////
이렇게 Clone하고 나면 Git 기능을 활용할 수 있는 Git 저장소 하나가 만들어진다.

[source,console]
----
$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head
----

(역주: 코드 틀린듯)

//////////////////////////
Note how there's a ``p4'' remote for the Perforce server, but everything else looks like a standard clone.
Actually, that's a bit misleading; there isn't actually a remote there.
//////////////////////////
Perforce 서버를 가리키는 ``p4'' 리모트가 Perforce 서버에 어떤식으로 접근할런지는 알 수 없지만 어찌되었든 Clone이 잘 된 모습니다.
사실 Perforce 저장소도 실제 리모트에 있지 않기는 하다.

[source,console]
----
$ git remote -v
----

//////////////////////////
No remotes exist in this repository at all.
Git-p4 has created some refs to represent the state of the server, and they look like remote refs to `git log`, but they're not managed by Git itself, and you can't push to them.
//////////////////////////
리모트를 확인해보면 아무런 리모트 저장소도 설정되어 있지 않다.
git-p4는 리모트 서버의 상태를 보여주기 위해 몇 가지 Ref를 만든다. 이렇게 만들어진 Ref는 `git log`에서 리모트 브랜치처럼 보이지만 사실 Git이 관리하는 리모트가 아니기 때문에 해당 이름으로 Push 할 수는 없다.

//////////////////////////
====== Workflow
//////////////////////////
====== 워크플로우

//////////////////////////
Okay, let's do some work.
Let's assume you've made some progress on a very important feature, and you're ready to show it to the rest of your team.
//////////////////////////
준비를 마쳤으니 또 수정하고 커밋하고 Push 해보자.
로컬 저장소 기반으로 어떤 중요한 작업을 마치고 팀 동료들에게 공유할 준비를 마친 상태를 생각해본다.

[source,console]
----
$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
We've made two new commits that we're ready to submit to the Perforce server.
Let's check if anyone else was working today:
//////////////////////////
작업한 내용의 결과 커밋 두 개를 생성했고 Perforce 서버로 전송할 준비가 되었다.
Push 하기전에 다른 동료가 새로 추가한 수정사항이 있는지 확인한다.

[source,console]
----
$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
Looks like they were, and `master` and `p4/master` have diverged.
Perforce's branching system is _nothing_ like Git's, so submitting merge commits doesn't make any sense.
Git-p4 recommends that you rebase your commits, and even comes with a shortcut to do so:
//////////////////////////
팀 동료가 수정한 내용이 추가되어 `master` 브랜치와 `p4/master` 브랜치가 갈라지게 되었다.
Perforce의 브랜치 관리 방식은 Git과 달라서 Merge 커밋을 서버로 전송하면 안된다.
대신 git-p4는 아래와 같은 명령으로 커밋을 Rebase 하기를 권장한다.

[source,console]
----
$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

//////////////////////////
You can probably tell from the output, but `git p4 rebase` is a shortcut for `git p4 sync` followed by `git rebase p4/master`.
It's a bit smarter than that, especially when working with multiple branches, but this is a good approximation.
//////////////////////////
실행 결과를 보면 단순히 `git p4 rebase`는 `git rebase p4/master` 하고 `git p4 sync` 명령을 실행한것 처럼 보일 수 있다.
브랜치가 여러개인 상황에서 훨씬 효과를 보이지만 이렇게 생각해도 괜찮다.

//////////////////////////
Now our history is linear again, and we're ready to contribute our changes back to Perforce.
The `git p4 submit` command will try to create a new Perforce revision for every Git commit between `p4/master` and `master`.
Running it drops us into our favorite editor, and the contents of the file look something like this:
//////////////////////////
이제 커밋 히스토리가 일직선이 되었고 Perforce 서버로 공유할 준비를 마쳤다.
`git p4 submit` 명령은 `p4/master`와 `master` 사이에 있는 모든 커밋에 대해 새 Perforce 리비전을 생성한다.
명령을 실행하면 주로 쓰는 편집기가 뜨고 아래와 같은 내용으로 채워져있다.

[source,console]
----
# A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 </td>
 <td valign=top>
 Source and documentation for
-<a href="http://www.perforce.com/jam/jam.html">
+<a href="jam.html">
 Jam/MR</a>,
 a software build tool.
 </td>
----

//////////////////////////
This is mostly the same content you'd see by running `p4 submit`, except the stuff at the end which git-p4 has helpfully included.
Git-p4 tries to honor your Git and Perforce settings individually when it has to provide a name for a commit or changeset, but in some cases you want to override it.
For example, if the Git commit you're importing was written by a contributor who doesn't have a Perforce user account, you may still want the resulting changeset to look like they write it (and not you).
//////////////////////////
이 내용은 `p4 submit`을 실행했을 때 보이는 내용과 같다. 다만 아래쪽에 git-p4가 도움이 될 만한 내용을 추가로 넣은 부분을 제외하면 말이다.
git-p4는 커밋이나 Changeset을 생성할 때 사용할 저자 정보에 대해 Git과 Perforce의 각 설정을 최대한 존중한다. 경우에 따라 커밋을 Changeset으로 변환할 때 바꿔줘야 할 수도 있다.
Git 커밋으로 가져와서 사용한 커밋의 저자 정보가 Perforce에 등록되지 않은 사용자 계정이라도 이를 계속 유지하고자 할 수 있다.

//////////////////////////
Git-p4 has helpfully imported the message from the Git commit as the content for this Perforce changeset, so all we have to do is save and quit, twice (once for each commit).
The resulting shell output will look something like this:
//////////////////////////
git-p4가 Git 커밋의 내용을 바탕으로 Perforce Changeset의 메시지를 생성하기 때문에 보통 그냥 내용을 저장하고 편집기를 종료하면 된다. 커밋이 두 개 있으므로 저장하고 종료하기를 두 번 한다.
어쨌든간에 `git p4 submit`의 실행한 결과는 아래와 같다.

[source,console]
----
$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
The result is as though we just did a `git push`, which is the closest analogy to what actually did happen.
//////////////////////////
`git p4 submit`에 가까운 Git의 명령은 `push`이며 위의 결과를 보면 `git push` 명령을 실행한 것과 비슷한 결과를 볼 수 있다. 

//////////////////////////
Note that during this process every Git commit is turned into a Perforce changeset; if you want to squash them down into a single changeset, you can do that with an interactive rebase before running `git p4 submit`.
Also note that the SHA hashes of all the commits that were submitted as changesets have changed; this is because git-p4 adds a line to the end of each commit it converts:
//////////////////////////
Git 커밋 하나하나가 Perforce의 Changeset으로 변환된 모습을 살펴보기 바란다. Git 커밋 여러개를 하나의 Perforce Changeset으로 만들어서 보내려면 `git p4 submit` 명령을 실행하기 전에 Rebase로 커밋을 하나로 합치면 된다.
서버로 보낸 커밋의 SHA 해시를 보면 그 값이 바뀐 것을 볼 수 있다. git-p4가 Changeset으로 변환할 때 각 커밋 메시지의 마지막에 다음과 같은 한 줄을 추가하기 때문이다.

[source,console]
----
$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe <john@example.com>
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]
----

//////////////////////////
What happens if you try to submit a merge commit?
Let's give it a try.
Here's the situation we've gotten ourselves into:
//////////////////////////
Merge 커밋을 서버로 전송하면
어떤 일이 일어나는지 살펴보자.
아래와 같은 커밋 히스토리가 현재 처한 상황이라고 생각해보자.

[source,console]
----
$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
The Git and Perforce history diverge after 775a46f.
The Git side has two commits, then a merge commit with the Perforce head, then another commit.
We're going to try to submit these on top of a single changeset on the Perforce side.
Let's see what would happen if we tried to submit now:
//////////////////////////
775a46f 커밋 이후에 Git과 Perforce 히스토리가 갈라졌다.
Git으로 작업한쪽에는 커밋이 두 개, Perforce쪽에는 커밋 하나가 추가된 상황이고 Merge한 이후에 커밋 하나가 더 쌓인 히스토리다.
이러한 히스토리를 Perforce 히스토리 위에 위치하도록 Changeset을 만들어서 서버로 보낼 작정이다.
만약 지금 이러한 상황에서 바로 Perforce 서버로 히스토리를 보내게 되면 아래와 같이 된다.

[source,console]
----
$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address
----

//////////////////////////
The `-n` flag is short for `--dry-run`, which tries to report what would happen if the submit command were run for real.
In this case, it looks like we'd be creating three Perforce changesets, which correspond to the three non-merge commits that don't yet exist on the Perforce server.
That sounds like exactly what we want, let's see how it turns out:
//////////////////////////
`-n` 옵션은 `--dry-run` 옵션을 줄여서 쓰는 모양으로 명령을 실행했을 때 어떤 일이 벌어지는지 살제로 적용하지 않고 미리 알아보는 옵션이다.
위와 같은 경우 Perforce 서버엔 없는 로컬에서 작업한 결과로 생성한 커밋에 대한 3개의 Perforce Changeset이 만들어지는 것으로 보인다.
확실히 이 결과는 우리가 원하던 바이다.

[source,console]
----
$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
Our history became linear, just as though we had rebased before submitting (which is in fact exactly what happened).
This means you can be free to create, work on, throw away, and merge branches on the Git side without fear that your history will somehow become incompatible with Perforce.
If you can rebase it, you can contribute it to a Perforce server.
//////////////////////////
`-n` 옵션을 빼고 실제로 명령을 실행하고 나서 히스토리를 조회해보면 Rebase 하고 나서 전송한 것처럼 Merge 없이 히스토리가 일직선이 되었다.
이 결과가 말하는 바는 Git을 사용해서 자유롭게 브랜치를 만들고 버리고 Merge하고 하는데 걱정할 필요가 없다는 것을 말한다. 히스토리가 Perforce 상식에 어긋나게 되더라도 말이다.
물론 Rebase를 할 수 있다면 Rebase를 하고 나서 Perforce 서버로 전송해도 된다.

[[_git_p4_branches]]
//////////////////////////
====== Branching
//////////////////////////
====== 브랜치

//////////////////////////
If your Perforce project has multiple branches, you're not out of luck; git-p4 can handle that in a way that makes it feel like Git.
Let's say your Perforce depot is laid out like this:
//////////////////////////
Perforce 프로젝트에서 여러 브랜치를 사용하고 있다면 불행한 것이 아니다. git-p4를 통해 Git의 브랜치 처럼 Perforce의 브랜치도 쓸 수 있다.
Perforce Depot이 아래와 같이 히스토리를 관리한다 생각해보자.

[source]
----
//depot
  └── project
      ├── main
      └── dev
----

//////////////////////////
And let's say you have a `dev` branch, which has a view spec that looks like this:
//////////////////////////
`dev` 브랜치가 아래와 같은 View Spec을 갖고 있다면,

[source]
----
//depot/project/main/... //depot/project/dev/...
----

//////////////////////////
Git-p4 can automatically detect that situation and do the right thing:
//////////////////////////
아래와 같이 git-p4는 자동으로 브랜치 정보를 찾아서 정확하게 처리 할 수 있다.

[source,console]
----
$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init
----

//////////////////////////
Note the ``@all'' specifier in the depot path; that tells git-p4 to clone not just the latest changeset for that subtree, but all changesets that have ever touched those paths.
This is closer to Git's concept of a clone, but if you're working on a project with a long history, it could take a while.
//////////////////////////
Depot 경로에 ``@all''이라는 지정자를 통해 git-p4가 프로젝트를 Clone할 때 가장 마지막 Changeset만을 가져오는 것이 아니라 지정한 경로의 모든 Changeset을 가져오게 된다.
이 과정은 Git에서 살펴본 Clone의 개념과 비슷하다. 프로젝트트에 쌓인 히스토리가 많다면 이 때 Clone 작업을 처리하는데 시간이 오래 걸릴것이다.

//////////////////////////
The `--detect-branches` flag tells git-p4 to use Perforce's branch specs to map the branches to Git refs.
If these mappings aren't present on the Perforce server (which is a perfectly valid way to use Perforce), you can tell git-p4 what the branch mappings are, and you get the same result:
//////////////////////////
`--detect-branches` 옵션으로 git-p4가 Perforce의 브랜치를 Git의 브랜치로 매핑하여 불러들이도록 한다.
매핑 정보가 Perforce 서버에 존재하지 않더라도(사실 이런 방법이 Perforce를 제대로 쓰는 것이다) git-p4에게 브랜치 매핑 정보를 전달해서 위의 결과처럼 브랜치를 매핑할 수도 있다.

[source,console]
----
$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .
----

//////////////////////////
Setting the `git-p4.branchList` configuration variable to `main:dev` tells git-p4 that ``main'' and ``dev'' are both branches, and the second one is a child of the first one.
//////////////////////////
`git-p4.branchList` 설정에 `main:dev` 값을 저장해두면 git-p4는 ``main''과 ``dev''가 브랜치 이름이고 후자는 전자에서 갈라져나온 것이라 파악한다.

//////////////////////////
If we now `git checkout -b dev p4/project/dev` and make some commits, git-p4 is smart enough to target the right branch when we do `git p4 submit`.
Unfortunately, git-p4 can't mix shallow clones and multiple branches; if you have a huge project and want to work on more than one branch, you'll have to `git p4 clone` once for each branch you want to submit to.
//////////////////////////
이제 `git checkout -b dev p4/project/dev` 하고 커밋을 쌓게되면, git-p4는 `git p4 submit` 할 때 똘똘하게 알아서 브랜치를 잘 찾아서 Changeset을 보낸다.
안타깝게도 git-p4를 사용할 때 마지막 리비전만 받아와서 사용하는 Shallow Clone을해서는 다수의 브랜치를 사용할 수 없다. 엄청나게 큰 Perforce인데 꼭 다수의 브랜치에서 작업을해야만 한다면 브랜치별로 `git p4 clone`을 따로 해서 사용하는 수 밖에 없다.

//////////////////////////
For creating or integrating branches, you'll have to use a Perforce client.
Git-p4 can only sync and submit to existing branches, and it can only do it one linear changeset at a time.
If you merge two branches in Git and try to submit the new changeset, all that will be recorded is a bunch of file changes; the metadata about which branches are involved in the integration will be lost.
//////////////////////////
Perforce의 브랜치를 생성하거나 브랜치끼리 합치려면 Perforce 클라이언트가 반드시 필요하다.
git-p4는 단지 이미 존재하는 브랜치로부터 Changeset을 가져오거나 커밋을 보내는 일만 할 수 있으며 일직선 형태의 Changeset 히스토리만을 유지할 수 있다.
브랜치를 Git에서 Merge하고, 커밋을 Changeset으로 보내게되면 단순히 파일 변화만 기록되고 메타데이터에 어떤브랜치가 Merge 되었는지는 기록되지 않는다.

//////////////////////////
===== Git and Perforce Summary
//////////////////////////
===== Git-Perforce 함께쓰기 요약

//////////////////////////
Git-p4 makes it possible to use a Git workflow with a Perforce server, and it's pretty good at it.
However, it's important to remember that Perforce is in charge of the source, and you're only using Git to work locally.
Just be really careful about sharing Git commits; if you have a remote that other people use, don't push any commits that haven't already been submitted to the Perforce server.
//////////////////////////
git-p4를 통해 Git Workflow를 Perforce 서버를 쓰는 환경에서도 쓸 수 있으며 꽤 쓸만하게 작동한다.
단 한 가지 반드시 기억해두어야 할 점은 결국에는 Perforce가 프로젝트를 관리하는 것이며 Git은 로컬에서만 사용한다는 점이다.
따라서 Git 커밋을 Perforce 서버로 보내서 공유할 때는 항상 주의깊게 작업해야 한다. 한 번 Perforce 서버로 보낸 커밋은 다시 보내서는 안된다.

//////////////////////////
If you want to freely mix the use of Perforce and Git as clients for source control, and you can convince the server administrator to install it, Git Fusion makes using Git a first-class version-control client for a Perforce server.
//////////////////////////
프로젝트 버전관리를 하기 위해 Perforce와 Git 클라이언트를 자유로이 함께 사용할 환경이고 서버를 관리할 수 있는 권한이 있다면 Git Fusion을 설치해서 매우 우아하게 Git을 Perforce 클라이언트로 사용할 수도 있다.