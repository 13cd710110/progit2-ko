[[_subtree_merge]]
///////////////////
===== Subtree Merging
///////////////////
===== 서브트리 Merge

///////////////////
The idea of the subtree merge is that you have two projects, and one of the projects maps to a subdirectory of the other one and vice versa.
When you specify a subtree merge, Git is often smart enough to figure out that one is a subtree of the other and merge appropriately.
///////////////////
서브트리 Merge의 개념은 프로젝트 두 개가 있을 때 한 프로젝트를 다른 프로젝트의 하위 디렉토리로 매핑하여 사용하는 것이다.
Merge 전략으로 서브트리(Subtree)를 사용하는 경우 Git은 매우 똑똑하게 서브트리를 찾아서 메인 프로젝트로 서브프로젝트의 내용을 Merge 한다.

///////////////////
We'll go through an example of adding a separate project into an existing project and then merging the code of the second into a subdirectory of the first.
///////////////////
예제를 통해 한 저장소에 완전히 다른 프로젝트의 리모트 저장소를 추가하고 데이터를 가져와서 Merge까지 하는 과정을 살펴보기로 한다.

///////////////////
First, we'll add the Rack application to our project.
We'll add the Rack project as a remote reference in our own project and then check it out into its own branch:
///////////////////
먼저 Rack 프로젝트 현재 프로젝트에 추가해야 한다.
Rack 프로젝트의 리모트 저장소를 현재 프로젝트의 리모트로 추가하고 Rack 프로젝트의 브랜치와 히스토리를 가져와(Fetch) 확인한다.

[source,console]
----
$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -> rack_remote/build
 * [new branch]      master     -> rack_remote/master
 * [new branch]      rack-0.4   -> rack_remote/rack-0.4
 * [new branch]      rack-0.9   -> rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"
----

///////////////////
Now we have the root of the Rack project in our `rack_branch` branch and our own project in the `master` branch.
If you check out one and then the other, you can see that they have different project roots:
///////////////////
(역주: `git fetch rack_remote` 명령의 결과에서 `warning: no common commits` 메시지를 주목해야 한다.)
위와 같이 실행하면 `rack_branch` 브랜치에 Rack 프로젝트가 위치하게 된다. 작업하던 현재 프로젝트는 `master` 브랜치에 있다.
`checkout` 명령으로 두 브랜치를 이동해보면 전혀 다른 두 프로젝트가 한 저장소에 있는 것 처럼 보인다.

[source,console]
----
$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README
----

///////////////////
This is sort of a strange concept. Not all the branches in your repository actually have to be branches of the same project. It's not common, because it's rarely helpful, but it's fairly easy to have branches contain completely different histories.
///////////////////
상당히 요상한 방식으로 Git을 활용하는 예이다. 저장소의 모든 브랜치가 동일한 프로젝트를 바탕으로 이루어지지 않을 수도 있는 예이다. 물론 이렇게 사용하는 경우 브랜치는 서로 완전히 다른 히스토리를 갖기 때문에 여러가지 기능을 사용할 수 없어 얻을 수 있는 이득이 없으므로 이런 방식을 거의 사용하지 않는다.

///////////////////
In this case, we want to pull the Rack project into our `master` project as a subdirectory.
We can do that in Git with `git read-tree`.
You’ll learn more about `read-tree` and its friends in <<_git_internals>>, but for now know that it reads the root tree of one branch into your current staging area and working directory.
We just switched back to your `master` branch, and we pull the `rack_branch` branch into the `rack` subdirectory of our `master` branch of our main project:
///////////////////
위 예제에서 Rack 프로젝트를 `master` 브랜치의 프로젝트 안에 하위 디렉토리로 만들어 사용하는 것이 가능하다.
이는 `git read-tree` 명령으로 이룰 수 있다.
`read-tree` 명령과 같이 저수준 명령에 관련된 많은 내용은 <<_git_internals>>에서 다루고 있다. 간단히 말하자면 `read-tree` 명령은 어떤 브랜치로부터 루트 트리를 읽어서 현재 Staging Area나 워킹 디렉토리로 가져오는 일을 한다.
`master` 브랜치로 다시 Checkout 하고 `rack_branch` 브랜치를 `master` 브랜치의 프로젝트에서 `rack_branch` 이라는 하위 디렉토리로 만들어보자.

[source,console]
----
$ git read-tree --prefix=rack/ -u rack_branch
----

///////////////////
When we commit, it looks like we have all the Rack files under that subdirectory – as though we copied them in from a tarball.
What gets interesting is that we can fairly easily merge changes from one of the branches to the other.
So, if the Rack project updates, we can pull in upstream changes by switching to that branch and pulling:
///////////////////
이제 커밋을 하면 Rack 프로젝트의 모든 파일이 Tarball 압축파일을 풀어서 소스코드를 포함시킨것 같이 커밋에 새로 추가된다.
이렇게 쉽게 한 브랜치의 내용을 다른 브랜치에 Merge 시킬 수 있다는 점이 흥미롭지 않은가?
그렇다면 만약 Rack 프로젝트가 업데이트 되었다면 업데이트된 내용으로 `rack_branch` 브랜치도 `master` 브랜치도 업데이트할 수 있을까?

[source,console]
----
$ git checkout rack_branch
$ git pull
----

///////////////////
Then, we can merge those changes back into our `master` branch.
We can use `git merge -s subtree` and it will work fine; but Git will also merge the histories together, which we probably don’t want.
To pull in the changes and prepopulate the commit message, use the `--squash` and `--no-commit` options as well as the `-s subtree` strategy option:
///////////////////
위의 명령을 실행하고 업데이트된 결과를 `master` 브랜치로 Merge 할 수 있다.
`git merge -s subtree` 명령으로 Merge 할 수 있으며 잘 동작할 것이다. 다만 이렇게 Merge를 하면 Rack 프로젝트의 히스토리가 모두 `master` 브랜치에 기록되게 되는데 이를 원치 않을 수도 있다.
`- subtree` 전략 옵션을 사용할 때 `--squash`와 `--no-commit` 옵션을 함께 사용하면 한 커밋에 Rack 프로젝트를 한 내용을 담을 수 있다.

[source,console]
----
$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack --no-commit rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
----

///////////////////
All the changes from the Rack project are merged in and ready to be committed locally.
You can also do the opposite – make changes in the `rack` subdirectory of your master branch and then merge them into your `rack_branch` branch later to submit them to the maintainers or push them upstream.
///////////////////
위 명령을 실행하면 Rack 프로젝트에서 변경된 모든 부분이 `master` 브랜치로 반영되고 커밋을 만들 준비까지 완료시킨다.
반대로 `rack` 하위 디렉토리에서 변경한 내용을 `master` 브랜치에 기록하고 나중에 Rack 프로젝트로 공유하고자 할 때 `rack_branch`로 반영시켜 Push를 할 수도 있다.

///////////////////
This gives us a way to have a workflow somewhat similar to the submodule workflow without using submodules (which we will cover in <<_git_submodules>>). We can keep branches with other related projects in our repository and subtree merge them into our project occasionally. It is nice in some ways, for example all the code is committed to a single place. However, it has other drawbacks in that it's a bit more complex and easier to make mistakes in reintegrating changes or accidentally pushing a branch into an unrelated repository.
///////////////////
이런 방식은 서브모듈(<<_git_submodules>>에서 자세하게 다룬다)을 사용하지 않고 서브모듈을 관리할 수 있는 또 다른 워크플로우이다. 하나의 저장소 안에 관련된 다른 프로젝트 저장소의 내용을 유지하면서 때때로 서브트리 Merge 전략을 통해 업데이트까지 할 수 있는 것이다. 프로젝트에 관련된 모든 코드가 하나의 저장소에서 관리할 수 있다는 면에서 꽤 괜찮아보이는 방법이다. 다만 이렇게 저장소를 관리하는 방법은 저장소를 다루기 좀 복잡해지고 실수할 수 있는 확률이 높아지고 Push를 하거나 할 때 잘못할 수 있는 몇 가지 단점도 포함한다.

///////////////////
Another slightly weird thing is that to get a diff between what you have in your `rack` subdirectory and the code in your `rack_branch` branch – to see if you need to merge them – you can’t use the normal `diff` command.
Instead, you must run `git diff-tree` with the branch you want to compare to:
///////////////////
다른 또 요상한 부분은 `rack` 하위 디렉토리와 `rack_branch`의 차이점을 보기 위해 `diff` 명령을 사용하는 경우이다. Merge를 한다거나 해서 미리 두 차이를 보려면 일반적인 `diff` 명령을 사용할 수 없다.
대신 `git diff-tree` 명령을 사용해야만 비교할 수 있다.

[source,console]
----
$ git diff-tree -p rack_branch
----

///////////////////
Or, to compare what is in your `rack` subdirectory with what the `master` branch on the server was the last time you fetched, you can run
///////////////////
혹은 `rack` 하위 디렉토리가 Rack 프로젝트의 리모트 저장소 `master` 브랜치와 어떤 차이가 있는지 살펴보고 싶을 수도 있다. 마지막 Fetch한 리모트의 `master` 브랜치와 비교하려면 아래와 같은 명령을 사용한다.

[source,console]
----
$ git diff-tree -p rack_remote/master
----
